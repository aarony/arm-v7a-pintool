<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>Pin: Pin 2.0 User Guide</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.4.6 -->
<div class="tabs">
  <ul>
    <li id="current"><a href="index.html"><span>Main&nbsp;Page</span></a></li>
    <li><a href="modules.html"><span>Modules</span></a></li>
    <li><a href="namespaces.html"><span>Namespaces</span></a></li>
    <li><a href="classes.html"><span>Classes</span></a></li>
    <li>
      <form action="search.php" method="get">
        <table cellspacing="0" cellpadding="0" border="0">
          <tr>
            <td><label>&nbsp;<u>S</u>earch&nbsp;for&nbsp;</label></td>
            <td><input type="text" name="query" value="" size="20" accesskey="s"/></td>
          </tr>
        </table>
      </form>
    </li>
  </ul></div>
<h1>Pin 2.0 User Guide</h1>
<p>
by Robert Cohn and Robert Muth<p>
======================================================================================== <h2><a class="anchor" name="INTRO">
Introduction</a></h2>
========================================================================================<p>
Pin is a tool for the instrumentation of programs. It supports Linux executables for Intel (R) Xscale (R), IA-32, and Itanium (R) processors.<p>
Pin was designed to provides functionality similar to the popular ATOM toolkit for Compaq's Tru64 Unix on Alpha (c.f. <code><a href="http://search.hp.com/query.html?qt=atom+toolkit">http://search.hp.com/query.html?qt=atom+toolkit</a></code>), i.e. arbitrary code (written in C or C++) can be injected at arbitrary places in the executable.<p>
Unlike Atom, Pin does not instrument an executable statically by rewriting it, but rather adds the code dynamically while the executable is running. This also makes it possible to attach Pin to an already running process.<p>
Pin provides a rich API that abstracts away the underlying instruction set idiosyncracies and allows context information such as register contents to be passed to the injected code as parameters. Pin automatically saves and restores the registers that are overwritten by the injected code so the application continues to work. Limited access to symbol and debug information is available as well.<p>
Pin includes the source code for a large number of example instrumentation tools like basic block profilers, cache simulators, instruction trace generators, etc. It is easy to derive new tools using the examples as a template.<p>
Table of Contents<ul>
<li><a class="el" href="index.html#OVERVIEW">Overview</a> Description of how to instrument with Pin</li><li><a class="el" href="index.html#EXAMPLES">Examples</a> Example tools and explanation</li><li><a class="el" href="index.html#INSTALLATION">Installation</a> Instructions for installing Pin</li><li><a class="el" href="index.html#RESTRICTIONS">Restrictions</a> Unsupported features and restrictions</li><li><a class="el" href="group__API__REF.html">Pin API reference</a> Detailed descriptions of the API</li><li><a class="el" href="group__INSTLIB.html">Instrumentation Library</a> Library for common instrumentation tasks</li><li><a class="el" href="index.html#DEBUGGING">Debugging</a> Tips for debugging a Pintool</li><li><a class="el" href="index.html#PERFORMANCE">Performance Consideration</a> when writing a Pintool</li><li><a class="el" href="index.html#FEEDBACK">Feedback</a> Questions? Bugs?</li></ul>
<p>
======================================================================================== <h2><a class="anchor" name="OVERVIEW">
Overview</a></h2>
========================================================================================<h3><a class="anchor" name="Pin">
Pin</a></h3>
The best way to think about Pin is as a "just in time" (JIT) compiler. The input to this compiler is not bytecode, however, but a regular executable. Pin intercepts the execution of the first instruction of the executable and generates ("compiles") new code for the straight line code sequence starting at this instruction. It then transfers control to the generated sequence. The generated code sequence is almost identical to the original one, but Pin ensures that it regains control when a branch exits the sequence. After regaining control, Pin generates more code for the branch target and continues execution. Pin makes this efficient by keeping all of the generated code in memory so it can be reused and directly branching from one sequence to another.<p>
The only code ever executed is the generated code. The original code is only used for reference. When generating code, Pin gives the user an opportunity to inject their own code (instrumentation).<h3><a class="anchor" name="Pintools">
Pintools</a></h3>
Conceptually, instrumentation consists of two components:<p>
<ul>
<li>A mechanism that decides where and what code is inserted</li></ul>
<p>
<ul>
<li>The code to execute at insertion points</li></ul>
<p>
The Atom terms for the two component are <em>instrumentation</em> and <em>analysis</em> code. Atom actually separates these two components into different files. In Pin this separation is no longer necessary. Both components live in a single executable, a <em>Pintool</em>. Pintools can be thought of as plugins that can modify the code generation process inside Pin.<p>
The Pintool registers callback routines with Pin that are called from Pin whenever new code needs to be generated. This routine represents the instrumentation component. It inspects the code to be generated, investigates its static properties, and decides if and where to inject calls to analysis code. Those calls can target arbitrary functions inside the Pintool. Pin makes sure that register state is saved and restored as necessary and allow arguments to be passed to the functions.<h3><a class="anchor" name="Observations">
Observations</a></h3>
Since a Pintool works like a plugin, it must run in the same address space as Pin and the executable to be instrumented. Hence the Pintool has access to all of the executable's data. It also shares file descriptors and other process information with the executable.<p>
Pin and the Pintool control a program starting with the very first instruction. For executables compiled with shared libraries this implies that the execution of the dynamic loader and all shared libraries will be visible to the Pintool.<p>
When writing tools, it is more important to tune the analysis code than the instrumentation code. This is because the instrumentation is executed once, but analysis code is called many times.<h3><a class="anchor" name="GRAN">
Instrumentation Granularity</a></h3>
As described above, Pin's instrumentation is "just in time" (JIT). Instrumentation occurs immediately before a code sequence is executed for the first time. We call this mode of operation <em> trace instrumentation </em>.<p>
Trace instrumentation lets the Pintool inspect and instrument an executable one trace at a time. Traces usually begin at the target of a taken branch and end with an unconditional branch, including calls and returns. Pin guarantees that a trace is only entered at the top, but it may contain multiple exits. If a branch joins the middle of a trace, Pin constructs a new trace that begins with the branch target. Pin breaks the trace into basic blocks, <em>BBLs</em>. A BBL is a single entrance, single exit sequence of instructions. Branches to the middle of a bbl begin a new trace and hence a new BBL. It is often possible to insert a single analysis call for a BBL, instead of one analysis call for every instruction. Reducing the number of analysis calls makes instrumentation more efficient. Trace instrumentation utilizes the <a class="el" href="group__TRACE__BASIC__API.html#g3418f705242d4f3b60b98437226e522b">TRACE_AddInstrumentFunction</a> API call.<p>
As a convenience for Pintool writers, Pin also offers an <em> instruction instrumentation </em> mode which lets the tool inspect and instrument an executable a single instruction at a time. This is essentially identical to trace instrumentation where the Pintool writer has been freed from the responsibilty of iterating over the instructions inside a trace. As decribed under trace instrumentation, certain BBLs and the instructions inside of them may be generated (and hence instrumented) multiple times. Instruction instrumentation utilizes the <a class="el" href="group__INS__INST__API.html#g56957614e1271afdd912c485c87fd406">INS_AddInstrumentFunction</a> API call.<p>
Pin's instruction and trace instrumentation modes differ substantially from the way Atom instruments executables. Atom instruments an entire executable ahead of time in one single pass. Pin interleaves execution and instrumentation of an executable and code that is never executed is never instrumented.<p>
Sometimes, however, it can be useful to look at different granularity than a trace. For this purpose Pin offers two additional modes: image and routine instrumentation which are more similar to the ahead of time model used by Atom. These modes are implemented by "caching" instrumentation requests and hence incur a space overhead.<p>
Image instrumentation lets the Pintool inspect and instrument an entire image, IMG, when it is first loaded. A Pintool can walk the sections, SEC, of the image, the routines, RTN, of a section, and the instructions, INS of a routine. Instrumentation can be inserted so that it is executed before or after a routine is executed, or before or after an instruction is executed. Image instrumentation utilizes the <a class="el" href="group__IMG__BASIC__API.html#gde144ad2da442ec59c351475e42565b3">IMG_AddInstrumentFunction</a> API call. Image instrumentation depends on symbol information to determine routine boundaries hence <a class="el" href="group__PIN__CONTROL.html#g8cf4aca0b0bdbc7fc0ae965883d8e3c2">PIN_InitSymbols</a> must be called before <a class="el" href="group__PIN__CONTROL.html#g783d3bd40c3fb2ca51b1f9af31a70c9c">PIN_Init</a>.<p>
Routine instrumentation lets the Pintool inspect and instrument an entire routine before the first time it is called. A Pintool can walk the instructions of a routine. There is not enough information available to break the instructions into BBLs. Instrumentation can be inserted so that it is executed before or after a routine is executed, or before or after an instruction is executed. Routine instrumentation can be more efficient than image instrumentation in space and time when the only a small number of the routines in an image are executed. Routine instrumentation utilizes the <a class="el" href="group__RTN__BASIC__API.html#g1208c26573e12bec41d7ffa026dd3089">RTN_AddInstrumentFunction</a> API call. Instrumentation of routine exits does not work reliably in the presence of tail calls or when return instructions cannot reliably detected, e.g. for xscale executables .<p>
======================================================================================== <h2><a class="anchor" name="EXAMPLES">
Examples</a></h2>
========================================================================================<p>
To illustrate how to write Pintools, we present some simple examples. In the web based version of the manual, you can click on a function in the Pin API to see its documentation.<h3><a class="anchor" name="SimpleCount">
Simple Instruction Count (Instruction Instrumentation)</a></h3>
The example below instruments a program to count the total number of instructions executed. It inserts a call to <code>docount</code> before every instruction. When the program exits, it prints the count to <code>stderr</code>.<p>
Here is how to run it and the output:<p>
<div class="fragment"><pre class="fragment">$ pin -t inscount0 -- /bin/ls
Makefile          atrace.o     imageload.out  itrace      proccount
Makefile.example  imageload    inscount0      itrace.o    proccount.o
atrace            imageload.o  inscount0.o    itrace.out
Count 422838
$
</pre></div><p>
The example can be found in ManualExamples/inscount0.C<p>
<div class="fragment"><pre class="fragment"><span class="comment">/*BEGIN_LEGAL </span>
<span class="comment">INTEL CONFIDENTIAL</span>
<span class="comment">Copyright 2002-2005 Intel Corporation All Rights Reserved.</span>
<span class="comment"></span>
<span class="comment">The source code contained or described herein and all documents</span>
<span class="comment">related to the source code (Material) are owned by Intel Corporation</span>
<span class="comment">or its suppliers or licensors. Title to the Material remains with</span>
<span class="comment">Intel Corporation or its suppliers and licensors. The Material may</span>
<span class="comment">contain trade secrets and proprietary and confidential information of</span>
<span class="comment">Intel Corporation and its suppliers and licensors, and is protected by</span>
<span class="comment">worldwide copyright and trade secret laws and treaty provisions. No</span>
<span class="comment">part of the Material may be used, copied, reproduced, modified,</span>
<span class="comment">published, uploaded, posted, transmitted, distributed, or disclosed in</span>
<span class="comment">any way without Intels prior express written permission.  No license</span>
<span class="comment">under any patent, copyright, trade secret or other intellectual</span>
<span class="comment">property right is granted to or conferred upon you by disclosure or</span>
<span class="comment">delivery of the Materials, either expressly, by implication,</span>
<span class="comment">inducement, estoppel or otherwise. Any license under such intellectual</span>
<span class="comment">property rights must be express and approved by Intel in writing.</span>
<span class="comment"></span>
<span class="comment">Unless otherwise agreed by Intel in writing, you may not remove or</span>
<span class="comment">alter this notice or any other notice embedded in Materials by Intel</span>
<span class="comment">or Intels suppliers or licensors in any way.</span>
<span class="comment">END_LEGAL */</span>
<span class="preprocessor">#include &lt;iostream&gt;</span>
<span class="preprocessor">#include "pin.H"</span>

<span class="comment">// The running count of instructions is kept here</span>
UINT64 icount = 0;

<span class="comment">// This function is called before every instruction is executed</span>
VOID docount() { icount++; }
    
<span class="comment">// Pin calls this function every time a new instruction is encountered</span>
VOID Instruction(INS ins, VOID *v)
{
    <span class="comment">// Insert a call to docount before every instruction, no arguments are passed</span>
    <a class="code" href="group__INS__INST__API.html#g74a956a0acde197043d04f4adcde4626">INS_InsertCall</a>(ins, <a class="code" href="group__INST__ARGS.html#gg707ea08e31f44f4a81e2a7766123bad77c7cbebb7a62a40e9f803b1db2e6ce20">IPOINT_BEFORE</a>, (AFUNPTR)docount, <a class="code" href="group__INST__ARGS.html#gg089c27ca15e9ff139dd3a3f8a6f8451dea5ff6624d8e6a49ba1da2f696fdac85">IARG_END</a>);
}

<span class="comment">// This function is called when the application exits</span>
VOID Fini(INT32 code, VOID *v)
{
    std::cerr &lt;&lt; <span class="stringliteral">"Count "</span> &lt;&lt; icount &lt;&lt; endl;
}

<span class="comment">// argc, argv are the entire command line, including pin -t &lt;toolname&gt; -- ...</span>
<span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span> * argv[])
{
    <span class="comment">// Initialize pin</span>
    <a class="code" href="group__PIN__CONTROL.html#g783d3bd40c3fb2ca51b1f9af31a70c9c">PIN_Init</a>(argc, argv);

    <span class="comment">// Register Instruction to be called to instrument instructions</span>
    <a class="code" href="group__INS__INST__API.html#g56957614e1271afdd912c485c87fd406">INS_AddInstrumentFunction</a>(Instruction, 0);

    <span class="comment">// Register Fini to be called when the application exits</span>
    <a class="code" href="group__PIN__CONTROL.html#g879e5a50ab15c9468f2918b260294454">PIN_AddFiniFunction</a>(Fini, 0);
    
    <span class="comment">// Start the program, never returns</span>
    <a class="code" href="group__PIN__CONTROL.html#g70c7d6c2a0d8ddad7595cae915f9a9e7">PIN_StartProgram</a>();
    
    <span class="keywordflow">return</span> 0;
}
</pre></div><h3><a class="anchor" name="IAddressTrace">
Instruction Address Trace (Instruction Instrumentation)</a></h3>
In the previous example, we did not pass any arguments to <code>docount</code>, the analysis procedure. In this example, we show how to pass arguments. When calling an analysis procedure, Pin allows you to pass the instruction pointer, current value of registers, effective address of memory operations, constants, etc. For a complete list, see <a class="el" href="group__INST__ARGS.html#g089c27ca15e9ff139dd3a3f8a6f8451d">IARG_TYPE</a>.<p>
With a small change, we can turn the instruction counting example into a Pintool that prints the address of every instruction that is executed. This tool is useful for understanding the control flow of a program for debugging, or in processor design when simulating an instruction cache.<p>
We change the arguments to INS_InsertCall to pass the address of the instruction about to be executed. We replace <code>docount</code> with <code>printip</code>, which prints the instruction address. It writes it output to to the file <code>itrace.out</code>.<p>
This is how to run it and look at the output:<p>
<div class="fragment"><pre class="fragment">$ pin -t itrace -- /bin/ls
Makefile          atrace.o     imageload.out  itrace      proccount
Makefile.example  imageload    inscount0      itrace.o    proccount.o
atrace            imageload.o  inscount0.o    itrace.out
$ head itrace.out
0x40001e90
0x40001e91
0x40001ee4
0x40001ee5
0x40001ee7
0x40001ee8
0x40001ee9
0x40001eea
0x40001ef0
0x40001ee0
$
</pre></div><p>
The example can be found in ManualExamples/itrace.C<p>
<div class="fragment"><pre class="fragment"><span class="comment">/*BEGIN_LEGAL </span>
<span class="comment">INTEL CONFIDENTIAL</span>
<span class="comment">Copyright 2002-2005 Intel Corporation All Rights Reserved.</span>
<span class="comment"></span>
<span class="comment">The source code contained or described herein and all documents</span>
<span class="comment">related to the source code (Material) are owned by Intel Corporation</span>
<span class="comment">or its suppliers or licensors. Title to the Material remains with</span>
<span class="comment">Intel Corporation or its suppliers and licensors. The Material may</span>
<span class="comment">contain trade secrets and proprietary and confidential information of</span>
<span class="comment">Intel Corporation and its suppliers and licensors, and is protected by</span>
<span class="comment">worldwide copyright and trade secret laws and treaty provisions. No</span>
<span class="comment">part of the Material may be used, copied, reproduced, modified,</span>
<span class="comment">published, uploaded, posted, transmitted, distributed, or disclosed in</span>
<span class="comment">any way without Intels prior express written permission.  No license</span>
<span class="comment">under any patent, copyright, trade secret or other intellectual</span>
<span class="comment">property right is granted to or conferred upon you by disclosure or</span>
<span class="comment">delivery of the Materials, either expressly, by implication,</span>
<span class="comment">inducement, estoppel or otherwise. Any license under such intellectual</span>
<span class="comment">property rights must be express and approved by Intel in writing.</span>
<span class="comment"></span>
<span class="comment">Unless otherwise agreed by Intel in writing, you may not remove or</span>
<span class="comment">alter this notice or any other notice embedded in Materials by Intel</span>
<span class="comment">or Intels suppliers or licensors in any way.</span>
<span class="comment">END_LEGAL */</span>
<span class="preprocessor">#include &lt;stdio.h&gt;</span>
<span class="preprocessor">#include "pin.H"</span>

FILE * trace;

<span class="comment">// This function is called before every instruction is executed</span>
<span class="comment">// and prints the IP</span>
VOID printip(VOID *ip) { fprintf(trace, <span class="stringliteral">"%p\n"</span>, ip); }

<span class="comment">// Pin calls this function every time a new instruction is encountered</span>
VOID Instruction(INS ins, VOID *v)
{
    <span class="comment">// Insert a call to printip before every instruction, and pass it the IP</span>
    <a class="code" href="group__INS__INST__API.html#g74a956a0acde197043d04f4adcde4626">INS_InsertCall</a>(ins, <a class="code" href="group__INST__ARGS.html#gg707ea08e31f44f4a81e2a7766123bad77c7cbebb7a62a40e9f803b1db2e6ce20">IPOINT_BEFORE</a>, (AFUNPTR)printip, <a class="code" href="group__INST__ARGS.html#gg089c27ca15e9ff139dd3a3f8a6f8451d623ad95758bce14fcb9427beef53736a">IARG_INST_PTR</a>, <a class="code" href="group__INST__ARGS.html#gg089c27ca15e9ff139dd3a3f8a6f8451dea5ff6624d8e6a49ba1da2f696fdac85">IARG_END</a>);
}

<span class="comment">// This function is called when the application exits</span>
VOID Fini(INT32 code, VOID *v)
{
    fprintf(trace, <span class="stringliteral">"#eof\n"</span>);
    fclose(trace);
}

<span class="comment">// argc, argv are the entire command line, including pin -t &lt;toolname&gt; -- ...</span>
<span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span> * argv[])
{
    trace = fopen(<span class="stringliteral">"itrace.out"</span>, <span class="stringliteral">"w"</span>);
    
    <span class="comment">// Initialize pin</span>
    <a class="code" href="group__PIN__CONTROL.html#g783d3bd40c3fb2ca51b1f9af31a70c9c">PIN_Init</a>(argc, argv);

    <span class="comment">// Register Instruction to be called to instrument instructions</span>
    <a class="code" href="group__INS__INST__API.html#g56957614e1271afdd912c485c87fd406">INS_AddInstrumentFunction</a>(Instruction, 0);

    <span class="comment">// Register Fini to be called when the application exits</span>
    <a class="code" href="group__PIN__CONTROL.html#g879e5a50ab15c9468f2918b260294454">PIN_AddFiniFunction</a>(Fini, 0);
    
    <span class="comment">// Start the program, never returns</span>
    <a class="code" href="group__PIN__CONTROL.html#g70c7d6c2a0d8ddad7595cae915f9a9e7">PIN_StartProgram</a>();
    
    <span class="keywordflow">return</span> 0;
}
</pre></div><h3><a class="anchor" name="MAddressTrace">
Memory Reference Trace (Instruction Instrumentation)</a></h3>
The previous example instruments all instructions. Sometimes a tool may only want to instrument a class of instructions, like memory operations or branch instructions. A tool can do this by using the Pin API which includes functions that classify and examine instructions. The basic API is common to all instruction sets and is described <a class="el" href="group__INS__BASIC__API.html">here.</a> In addition, there is an instruction set specific API for <a class="el" href="group__INS__BASIC__API__ARM.html">arm,</a> <a class="el" href="group__INS__BASIC__API__IA32.html">ia32,</a> and <a class="el" href="group__INS__BASIC__API__IPF.html">ipf.</a><p>
In this example, we show how to do more selective instrumentation by examining the instructions. This tool generates a trace of all memory addresses referenced by a program. This is also useful for debugging and for simulating a data cache in a processor.<p>
We only instrument instructions that read or write memory. We also use INS_InsertPredicatedCall instead of INS_InsertCall to avoid generating references to instructions that are predicated and the predicate is false (predication is only relevant for Xscale and Itanium).<p>
Since the instrumentation functions are only called once and the analysis functions are called every time an instruction is executed, it is much faster to only instrument the memory operations, as compared to the previous instruction trace example that instruments every instruction.<p>
Here is how to run it and the sample output:<p>
<div class="fragment"><pre class="fragment">$ pin -t pinatrace -- /bin/ls
Makefile          atrace.o    imageload.o    inscount0.o  itrace.out
Makefile.example  atrace.out  imageload.out  itrace       proccount
atrace            imageload   inscount0      itrace.o     proccount.o
$ head pinatrace.out 
0x40001ee0: R 0xbfffe798
0x40001efd: W 0xbfffe7d4
0x40001f09: W 0xbfffe7d8
0x40001f20: W 0xbfffe864
0x40001f20: W 0xbfffe868
0x40001f20: W 0xbfffe86c
0x40001f20: W 0xbfffe870
0x40001f20: W 0xbfffe874
0x40001f20: W 0xbfffe878
0x40001f20: W 0xbfffe87c
$
</pre></div><p>
The example can be found in ManualExamples/pinatrace.C<p>
<div class="fragment"><pre class="fragment"><span class="comment">/*BEGIN_LEGAL </span>
<span class="comment">INTEL CONFIDENTIAL</span>
<span class="comment">Copyright 2002-2005 Intel Corporation All Rights Reserved.</span>
<span class="comment"></span>
<span class="comment">The source code contained or described herein and all documents</span>
<span class="comment">related to the source code (Material) are owned by Intel Corporation</span>
<span class="comment">or its suppliers or licensors. Title to the Material remains with</span>
<span class="comment">Intel Corporation or its suppliers and licensors. The Material may</span>
<span class="comment">contain trade secrets and proprietary and confidential information of</span>
<span class="comment">Intel Corporation and its suppliers and licensors, and is protected by</span>
<span class="comment">worldwide copyright and trade secret laws and treaty provisions. No</span>
<span class="comment">part of the Material may be used, copied, reproduced, modified,</span>
<span class="comment">published, uploaded, posted, transmitted, distributed, or disclosed in</span>
<span class="comment">any way without Intels prior express written permission.  No license</span>
<span class="comment">under any patent, copyright, trade secret or other intellectual</span>
<span class="comment">property right is granted to or conferred upon you by disclosure or</span>
<span class="comment">delivery of the Materials, either expressly, by implication,</span>
<span class="comment">inducement, estoppel or otherwise. Any license under such intellectual</span>
<span class="comment">property rights must be express and approved by Intel in writing.</span>
<span class="comment"></span>
<span class="comment">Unless otherwise agreed by Intel in writing, you may not remove or</span>
<span class="comment">alter this notice or any other notice embedded in Materials by Intel</span>
<span class="comment">or Intels suppliers or licensors in any way.</span>
<span class="comment">END_LEGAL */</span>
<span class="comment">/*</span>
<span class="comment"> *  This file contains an ISA-portable PIN tool for tracing memory accesses.</span>
<span class="comment"> */</span>

<span class="preprocessor">#include &lt;stdio.h&gt;</span>
<span class="preprocessor">#include "pin.H"</span>


FILE * trace;

<span class="comment">// Print a memory read record</span>
VOID RecordMemRead(VOID * ip, VOID * addr)
{
    fprintf(trace,<span class="stringliteral">"%p: R %p\n"</span>, ip, addr);
}

<span class="comment">// Print a memory write record</span>
VOID RecordMemWrite(VOID * ip, VOID * addr)
{
    fprintf(trace,<span class="stringliteral">"%p: W %p\n"</span>, ip, addr);
}

<span class="comment">// Is called for every instruction and instruments reads and writes</span>
VOID Instruction(INS ins, VOID *v)
{
    <span class="comment">// instruments loads using a predicated call, i.e.</span>
    <span class="comment">// the call happens iff the load will be actually executed</span>
    <span class="comment">// (this does not matter for ia32 but arm and ipf have predicated instructions)</span>
    <span class="keywordflow">if</span> (<a class="code" href="group__INS__BASIC__API__GEN__IA32.html#g53406fedba9cbde8633a8da58c262e31">INS_IsMemoryRead</a>(ins))
    {
        <a class="code" href="group__INS__INST__API.html#g26d02bff719bf8600421895956804252">INS_InsertPredicatedCall</a>(
            ins, <a class="code" href="group__INST__ARGS.html#gg707ea08e31f44f4a81e2a7766123bad77c7cbebb7a62a40e9f803b1db2e6ce20">IPOINT_BEFORE</a>, (AFUNPTR)RecordMemRead,
            <a class="code" href="group__INST__ARGS.html#gg089c27ca15e9ff139dd3a3f8a6f8451d623ad95758bce14fcb9427beef53736a">IARG_INST_PTR</a>,
            <a class="code" href="group__INST__ARGS.html#gg089c27ca15e9ff139dd3a3f8a6f8451d2138787daf04a57e6684eb0b368e120e">IARG_MEMORYREAD_EA</a>,
            <a class="code" href="group__INST__ARGS.html#gg089c27ca15e9ff139dd3a3f8a6f8451dea5ff6624d8e6a49ba1da2f696fdac85">IARG_END</a>);
    }

    <span class="comment">// instruments stores using a predicated call, i.e.</span>
    <span class="comment">// the call happens iff the store will be actually executed</span>
    <span class="keywordflow">if</span> (<a class="code" href="group__INS__BASIC__API__GEN__IA32.html#g77f11ad8c2c1f2cbe5d3aa9fb33f8c1f">INS_IsMemoryWrite</a>(ins))
    {
        <a class="code" href="group__INS__INST__API.html#g26d02bff719bf8600421895956804252">INS_InsertPredicatedCall</a>(
            ins, <a class="code" href="group__INST__ARGS.html#gg707ea08e31f44f4a81e2a7766123bad77c7cbebb7a62a40e9f803b1db2e6ce20">IPOINT_BEFORE</a>, (AFUNPTR)RecordMemWrite,
            <a class="code" href="group__INST__ARGS.html#gg089c27ca15e9ff139dd3a3f8a6f8451d623ad95758bce14fcb9427beef53736a">IARG_INST_PTR</a>,
            <a class="code" href="group__INST__ARGS.html#gg089c27ca15e9ff139dd3a3f8a6f8451d92be352ec619bbd3be69fed773c011a2">IARG_MEMORYWRITE_EA</a>,
            <a class="code" href="group__INST__ARGS.html#gg089c27ca15e9ff139dd3a3f8a6f8451dea5ff6624d8e6a49ba1da2f696fdac85">IARG_END</a>);
    }
}

VOID Fini(INT32 code, VOID *v)
{
    fprintf(trace, <span class="stringliteral">"#eof\n"</span>);
    fclose(trace);
}


<span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span> *argv[])
{
    <a class="code" href="group__PIN__CONTROL.html#g783d3bd40c3fb2ca51b1f9af31a70c9c">PIN_Init</a>(argc, argv);

    trace = fopen(<span class="stringliteral">"pinatrace.out"</span>, <span class="stringliteral">"w"</span>);

    <a class="code" href="group__INS__INST__API.html#g56957614e1271afdd912c485c87fd406">INS_AddInstrumentFunction</a>(Instruction, 0);
    <a class="code" href="group__PIN__CONTROL.html#g879e5a50ab15c9468f2918b260294454">PIN_AddFiniFunction</a>(Fini, 0);

    <span class="comment">// Never returns</span>
    <a class="code" href="group__PIN__CONTROL.html#g70c7d6c2a0d8ddad7595cae915f9a9e7">PIN_StartProgram</a>();
    
    <span class="keywordflow">return</span> 0;
}
</pre></div><h3><a class="anchor" name="ImageLoad">
Detecting the Loading and Unloading of Images (Image Instrumentation)</a></h3>
The example below prints a message to a trace file every time and image is loaded or unloaded. It really abuses the image instrumentation mode as the Pintool neither inspects the image nor adds instrumentation code.<p>
If you invoke it on ls, you would see this output:<p>
<div class="fragment"><pre class="fragment">$ pin -t imageload -- /bin/ls
Makefile          atrace.o    imageload.o    inscount0.o  proccount
Makefile.example  atrace.out  imageload.out  itrace       proccount.o
atrace            imageload   inscount0      itrace.o     trace.out
$ cat imageload.out 
Loading /bin/ls
Loading /lib/ld-linux.so.2
Loading /lib/libtermcap.so.2
Loading /lib/i686/libc.so.6
Unloading /bin/ls
Unloading /lib/ld-linux.so.2
Unloading /lib/libtermcap.so.2
Unloading /lib/i686/libc.so.6
$ 
</pre></div><p>
The example can be found in ManualExamples/imageload.C<p>
<div class="fragment"><pre class="fragment"><span class="comment">/*BEGIN_LEGAL </span>
<span class="comment">INTEL CONFIDENTIAL</span>
<span class="comment">Copyright 2002-2005 Intel Corporation All Rights Reserved.</span>
<span class="comment"></span>
<span class="comment">The source code contained or described herein and all documents</span>
<span class="comment">related to the source code (Material) are owned by Intel Corporation</span>
<span class="comment">or its suppliers or licensors. Title to the Material remains with</span>
<span class="comment">Intel Corporation or its suppliers and licensors. The Material may</span>
<span class="comment">contain trade secrets and proprietary and confidential information of</span>
<span class="comment">Intel Corporation and its suppliers and licensors, and is protected by</span>
<span class="comment">worldwide copyright and trade secret laws and treaty provisions. No</span>
<span class="comment">part of the Material may be used, copied, reproduced, modified,</span>
<span class="comment">published, uploaded, posted, transmitted, distributed, or disclosed in</span>
<span class="comment">any way without Intels prior express written permission.  No license</span>
<span class="comment">under any patent, copyright, trade secret or other intellectual</span>
<span class="comment">property right is granted to or conferred upon you by disclosure or</span>
<span class="comment">delivery of the Materials, either expressly, by implication,</span>
<span class="comment">inducement, estoppel or otherwise. Any license under such intellectual</span>
<span class="comment">property rights must be express and approved by Intel in writing.</span>
<span class="comment"></span>
<span class="comment">Unless otherwise agreed by Intel in writing, you may not remove or</span>
<span class="comment">alter this notice or any other notice embedded in Materials by Intel</span>
<span class="comment">or Intels suppliers or licensors in any way.</span>
<span class="comment">END_LEGAL */</span>
<span class="comment">//</span>
<span class="comment">// This tool prints a trace of image load and unload events</span>
<span class="comment">//</span>

<span class="preprocessor">#include &lt;stdio.h&gt;</span>
<span class="preprocessor">#include "pin.H"</span>

FILE * trace;

<span class="comment">// Pin calls this function every time a new img is loaded</span>
<span class="comment">// It can instrument the image, but this example does not</span>
<span class="comment">// Note that imgs (including shared libraries) are loaded lazily</span>

VOID ImageLoad(IMG img, VOID *v)
{
    fprintf(trace, <span class="stringliteral">"Loading %s\n"</span>, <a class="code" href="group__IMG__BASIC__API.html#gbcd40629769c084935422817149fd52f">IMG_Name</a>(img).c_str());
}

<span class="comment">// Pin calls this function every time a new img is unloaded</span>
<span class="comment">// You can't instrument an image that is about to be unloaded</span>
VOID ImageUnload(IMG img, VOID *v)
{
    fprintf(trace, <span class="stringliteral">"Unloading %s\n"</span>, <a class="code" href="group__IMG__BASIC__API.html#gbcd40629769c084935422817149fd52f">IMG_Name</a>(img).c_str());
}

<span class="comment">// This function is called when the application exits</span>
<span class="comment">// It prints the name and count for each procedure</span>
VOID Fini(INT32 code, VOID *v)
{
    fclose(trace);
}

<span class="comment">// argc, argv are the entire command line, including pin -t &lt;toolname&gt; -- ...</span>
<span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span> * argv[])
{
    trace = fopen(<span class="stringliteral">"imageload.out"</span>, <span class="stringliteral">"w"</span>);

    <span class="comment">// Initialize symbol processing</span>
    <a class="code" href="group__PIN__CONTROL.html#g8cf4aca0b0bdbc7fc0ae965883d8e3c2">PIN_InitSymbols</a>();
    
    <span class="comment">// Initialize pin</span>
    <a class="code" href="group__PIN__CONTROL.html#g783d3bd40c3fb2ca51b1f9af31a70c9c">PIN_Init</a>(argc, argv);
    
    <span class="comment">// Register ImageLoad to be called when an image is loaded</span>
    <a class="code" href="group__IMG__BASIC__API.html#gde144ad2da442ec59c351475e42565b3">IMG_AddInstrumentFunction</a>(ImageLoad, 0);

    <span class="comment">// Register ImageUnload to be called when an image is unloaded</span>
    <a class="code" href="group__IMG__BASIC__API.html#g0ac18287da4b1d6c5880db5c03417983">IMG_AddUnloadFunction</a>(ImageUnload, 0);

    <span class="comment">// Register Fini to be called when the application exits</span>
    <a class="code" href="group__PIN__CONTROL.html#g879e5a50ab15c9468f2918b260294454">PIN_AddFiniFunction</a>(Fini, 0);
    
    <span class="comment">// Start the program, never returns</span>
    <a class="code" href="group__PIN__CONTROL.html#g70c7d6c2a0d8ddad7595cae915f9a9e7">PIN_StartProgram</a>();
    
    <span class="keywordflow">return</span> 0;
}
</pre></div><h3><a class="anchor" name="inscount1">
More Efficient Instruction Counting (Trace Instrumentation)</a></h3>
The example <a class="el" href="index.html#SimpleCount">Simple Instruction Count (Instruction Instrumentation)</a> computed the number of executed instructions by inserting a call before every instruction. In this example, we make it more efficient by counting the number of instructions in a BBL at instrumentation time, and incrementing the counter once per BBL, instead of once per instruction.<p>
The example can be found in ManualExamples/inscount1.C<p>
<div class="fragment"><pre class="fragment"><span class="comment">/*BEGIN_LEGAL </span>
<span class="comment">INTEL CONFIDENTIAL</span>
<span class="comment">Copyright 2002-2005 Intel Corporation All Rights Reserved.</span>
<span class="comment"></span>
<span class="comment">The source code contained or described herein and all documents</span>
<span class="comment">related to the source code (Material) are owned by Intel Corporation</span>
<span class="comment">or its suppliers or licensors. Title to the Material remains with</span>
<span class="comment">Intel Corporation or its suppliers and licensors. The Material may</span>
<span class="comment">contain trade secrets and proprietary and confidential information of</span>
<span class="comment">Intel Corporation and its suppliers and licensors, and is protected by</span>
<span class="comment">worldwide copyright and trade secret laws and treaty provisions. No</span>
<span class="comment">part of the Material may be used, copied, reproduced, modified,</span>
<span class="comment">published, uploaded, posted, transmitted, distributed, or disclosed in</span>
<span class="comment">any way without Intels prior express written permission.  No license</span>
<span class="comment">under any patent, copyright, trade secret or other intellectual</span>
<span class="comment">property right is granted to or conferred upon you by disclosure or</span>
<span class="comment">delivery of the Materials, either expressly, by implication,</span>
<span class="comment">inducement, estoppel or otherwise. Any license under such intellectual</span>
<span class="comment">property rights must be express and approved by Intel in writing.</span>
<span class="comment"></span>
<span class="comment">Unless otherwise agreed by Intel in writing, you may not remove or</span>
<span class="comment">alter this notice or any other notice embedded in Materials by Intel</span>
<span class="comment">or Intels suppliers or licensors in any way.</span>
<span class="comment">END_LEGAL */</span>
<span class="preprocessor">#include &lt;iostream&gt;</span>
<span class="preprocessor">#include "pin.H"</span>

<span class="comment">// The running count of instructions is kept here</span>
UINT64 icount = 0;

<span class="comment">// This function is called before every block</span>
VOID docount(INT32 c) { icount += c; }
    
<span class="comment">// Pin calls this function every time a new basic block is encountered</span>
<span class="comment">// It inserts a call to docount</span>
VOID Trace(<a class="code" href="group__TRACE__BASIC__API.html#g2546ffa074ba96447052652c556f0821">TRACE</a> trace, VOID *v)
{
    <span class="comment">// Visit every basic block  in the trace</span>
    <span class="keywordflow">for</span> (BBL bbl = <a class="code" href="group__TRACE__BASIC__API.html#g008abc5ba1af8d9e9cd073ffe0aefa18">TRACE_BblHead</a>(trace); <a class="code" href="group__BBL__BASIC__API.html#g58a8d019cd09ce46cfe431ec8f14a075">BBL_Valid</a>(bbl); bbl = <a class="code" href="group__BBL__BASIC__API.html#gdd7141abb47139b52922e04e0c4a10f3">BBL_Next</a>(bbl))
    {
        <span class="comment">// Insert a call to docount before every bbl, passing the number of instructions</span>
        <a class="code" href="group__BBL__BASIC__API.html#geee9d7a6253d49d226bbed3f35768169">BBL_InsertCall</a>(bbl, <a class="code" href="group__INST__ARGS.html#gg707ea08e31f44f4a81e2a7766123bad77c7cbebb7a62a40e9f803b1db2e6ce20">IPOINT_BEFORE</a>, (AFUNPTR)docount, <a class="code" href="group__INST__ARGS.html#gg089c27ca15e9ff139dd3a3f8a6f8451dbd19b79248899659441e56e4738d5bfd">IARG_UINT32</a>, <a class="code" href="group__BBL__BASIC__API.html#g76ceb2d9e0fb974d3c3769b2413ed634">BBL_NumIns</a>(bbl), <a class="code" href="group__INST__ARGS.html#gg089c27ca15e9ff139dd3a3f8a6f8451dea5ff6624d8e6a49ba1da2f696fdac85">IARG_END</a>);
    }
}

<span class="comment">// This function is called when the application exits</span>
VOID Fini(INT32 code, VOID *v)
{
    std::cerr &lt;&lt; <span class="stringliteral">"Count "</span> &lt;&lt; icount &lt;&lt; endl;
}

<span class="comment">// argc, argv are the entire command line, including pin -t &lt;toolname&gt; -- ...</span>
<span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span> * argv[])
{
    <span class="comment">// Initialize pin</span>
    <a class="code" href="group__PIN__CONTROL.html#g783d3bd40c3fb2ca51b1f9af31a70c9c">PIN_Init</a>(argc, argv);

    <span class="comment">// Register Instruction to be called to instrument instructions</span>
    <a class="code" href="group__TRACE__BASIC__API.html#g3418f705242d4f3b60b98437226e522b">TRACE_AddInstrumentFunction</a>(Trace, 0);

    <span class="comment">// Register Fini to be called when the application exits</span>
    <a class="code" href="group__PIN__CONTROL.html#g879e5a50ab15c9468f2918b260294454">PIN_AddFiniFunction</a>(Fini, 0);
    
    <span class="comment">// Start the program, never returns</span>
    <a class="code" href="group__PIN__CONTROL.html#g70c7d6c2a0d8ddad7595cae915f9a9e7">PIN_StartProgram</a>();
    
    <span class="keywordflow">return</span> 0;
}
</pre></div><h3><a class="anchor" name="ProcInstrCount">
Procedure Instruction Count (Routine Instrumentation)</a></h3>
The example below instruments a program to count the number of times a procedure is called, and the total number of instructions executed in each procedure. When it finishes, it prints a profile to proccount.out<p>
Executing the tool and sample output:<p>
<div class="fragment"><pre class="fragment">$ pin -t proccount -- /bin/grep proccount.C Makefile
proccount_SOURCES = proccount.C
$ head proccount.out
              Procedure           Image            Address        Calls Instructions
                  _fini       libc.so.6         0x40144d00            1           21
__deregister_frame_info       libc.so.6         0x40143f60            2           70
  __register_frame_info       libc.so.6         0x40143df0            2           62
              fde_merge       libc.so.6         0x40143870            0            8
            __init_misc       libc.so.6         0x40115824            1           85
            __getclktck       libc.so.6         0x401157f4            0            2
                 munmap       libc.so.6         0x40112ca0            1            9
                   mmap       libc.so.6         0x40112bb0            1           23
            getpagesize       libc.so.6         0x4010f934            2           26
$
</pre></div><p>
The example can be found in ManualExamples/proccount.C<p>
<div class="fragment"><pre class="fragment"><span class="comment">/*BEGIN_LEGAL </span>
<span class="comment">INTEL CONFIDENTIAL</span>
<span class="comment">Copyright 2002-2005 Intel Corporation All Rights Reserved.</span>
<span class="comment"></span>
<span class="comment">The source code contained or described herein and all documents</span>
<span class="comment">related to the source code (Material) are owned by Intel Corporation</span>
<span class="comment">or its suppliers or licensors. Title to the Material remains with</span>
<span class="comment">Intel Corporation or its suppliers and licensors. The Material may</span>
<span class="comment">contain trade secrets and proprietary and confidential information of</span>
<span class="comment">Intel Corporation and its suppliers and licensors, and is protected by</span>
<span class="comment">worldwide copyright and trade secret laws and treaty provisions. No</span>
<span class="comment">part of the Material may be used, copied, reproduced, modified,</span>
<span class="comment">published, uploaded, posted, transmitted, distributed, or disclosed in</span>
<span class="comment">any way without Intels prior express written permission.  No license</span>
<span class="comment">under any patent, copyright, trade secret or other intellectual</span>
<span class="comment">property right is granted to or conferred upon you by disclosure or</span>
<span class="comment">delivery of the Materials, either expressly, by implication,</span>
<span class="comment">inducement, estoppel or otherwise. Any license under such intellectual</span>
<span class="comment">property rights must be express and approved by Intel in writing.</span>
<span class="comment"></span>
<span class="comment">Unless otherwise agreed by Intel in writing, you may not remove or</span>
<span class="comment">alter this notice or any other notice embedded in Materials by Intel</span>
<span class="comment">or Intels suppliers or licensors in any way.</span>
<span class="comment">END_LEGAL */</span>
<span class="comment">//</span>
<span class="comment">// This tool counts the number of a routine is executed and counts</span>
<span class="comment">// the number of instructions executed in a routine</span>
<span class="comment">//</span>

<span class="preprocessor">#include &lt;fstream&gt;</span>
<span class="preprocessor">#include &lt;iomanip&gt;</span>
<span class="preprocessor">#include "pin.H"</span>

<span class="comment">// Holds instruction count for a single procedure</span>
<span class="keyword">typedef</span> <span class="keyword">struct </span>RtnCount
{
    string _name;
    string _image;
    ADDRINT _address;
    RTN _rtn;
    UINT64 _rtnCount;
    UINT64 _icount;
    <span class="keyword">struct </span>RtnCount * _next;
} RTN_COUNT;

<span class="comment">// Linked list of instruction counts for each routine</span>
RTN_COUNT * RtnList = 0;

<span class="comment">// This function is called before every instruction is executed</span>
VOID docount(UINT64 * counter)
{
    (*counter)++;
}
    
<span class="keyword">const</span> <span class="keywordtype">char</span> * StripPath(<span class="keyword">const</span> <span class="keywordtype">char</span> * path)
{
    <span class="keyword">const</span> <span class="keywordtype">char</span> * file = strrchr(path,<span class="charliteral">'/'</span>);
    <span class="keywordflow">if</span> (file)
        <span class="keywordflow">return</span> file+1;
    <span class="keywordflow">else</span>
        <span class="keywordflow">return</span> path;
}

<span class="comment">// Pin calls this function every time a new rtn is executed</span>
VOID Routine(RTN rtn, VOID *v)
{
    
    <span class="comment">// Allocate a counter for this routine</span>
    RTN_COUNT * rc = <span class="keyword">new</span> RTN_COUNT;

    <span class="comment">// The RTN goes away when the image is unloaded, so save it now</span>
    <span class="comment">// because we need it in the fini</span>
    rc-&gt;_name = <a class="code" href="group__RTN__BASIC__API.html#gf9d9689a59240ecc29c80d584f268c72">RTN_Name</a>(rtn);
    rc-&gt;_image = StripPath(<a class="code" href="group__IMG__BASIC__API.html#gbcd40629769c084935422817149fd52f">IMG_Name</a>(<a class="code" href="group__SEC__BASIC__API.html#gc5fdcf087a172e67c1d9800c34b3c9cd">SEC_Img</a>(<a class="code" href="group__RTN__BASIC__API.html#g4883c839d424578a9f6983d05e6a9a12">RTN_Sec</a>(rtn))).c_str());
    rc-&gt;_address = <a class="code" href="group__RTN__BASIC__API.html#g83a81fae96c9faabe0f1c90a0d7e865f">RTN_Address</a>(rtn);
    rc-&gt;_icount = 0;
    rc-&gt;_rtnCount = 0;

    <span class="comment">// Add to list of routines</span>
    rc-&gt;_next = RtnList;
    RtnList = rc;
            
    <a class="code" href="group__RTN__BASIC__API.html#gf8714086f8aebc9feacccc8cd02dc561">RTN_Open</a>(rtn);
            
    <span class="comment">// Insert a call at the entry point of a routine to increment the call count</span>
    <a class="code" href="group__RTN__BASIC__API.html#g76bde295a78d1232fd6ff98a5ff011cf">RTN_InsertCall</a>(rtn, <a class="code" href="group__INST__ARGS.html#gg707ea08e31f44f4a81e2a7766123bad77c7cbebb7a62a40e9f803b1db2e6ce20">IPOINT_BEFORE</a>, (AFUNPTR)docount, <a class="code" href="group__INST__ARGS.html#gg089c27ca15e9ff139dd3a3f8a6f8451d7a11763427dff3afb81caab97b02881b">IARG_PTR</a>, &amp;(rc-&gt;_rtnCount), <a class="code" href="group__INST__ARGS.html#gg089c27ca15e9ff139dd3a3f8a6f8451dea5ff6624d8e6a49ba1da2f696fdac85">IARG_END</a>);
    
    <span class="comment">// For each instruction of the routine</span>
    <span class="keywordflow">for</span> (INS ins = <a class="code" href="group__RTN__BASIC__API.html#gb1bd91206939b88057664c46ef8eac86">RTN_InsHead</a>(rtn); <a class="code" href="group__INS__BASIC__API__GEN__IA32.html#g3a8b61fffa9ae4ad9f899b21ce37397c">INS_Valid</a>(ins); ins = <a class="code" href="group__INS__BASIC__API__GEN__IA32.html#g227ce58a739b1573125c11071ecb48de">INS_Next</a>(ins))
    {
        <span class="comment">// Insert a call to docount to increment the instruction counter for this rtn</span>
        <a class="code" href="group__INS__INST__API.html#g74a956a0acde197043d04f4adcde4626">INS_InsertCall</a>(ins, <a class="code" href="group__INST__ARGS.html#gg707ea08e31f44f4a81e2a7766123bad77c7cbebb7a62a40e9f803b1db2e6ce20">IPOINT_BEFORE</a>, (AFUNPTR)docount, <a class="code" href="group__INST__ARGS.html#gg089c27ca15e9ff139dd3a3f8a6f8451d7a11763427dff3afb81caab97b02881b">IARG_PTR</a>, &amp;(rc-&gt;_icount), <a class="code" href="group__INST__ARGS.html#gg089c27ca15e9ff139dd3a3f8a6f8451dea5ff6624d8e6a49ba1da2f696fdac85">IARG_END</a>);
    }

    
    <a class="code" href="group__RTN__BASIC__API.html#g37272253377eb65c9eb5ff47ec4f1e6b">RTN_Close</a>(rtn);
}

<span class="comment">// This function is called when the application exits</span>
<span class="comment">// It prints the name and count for each procedure</span>
VOID Fini(INT32 code, VOID *v)
{
    ofstream count(<span class="stringliteral">"proccount.out"</span>);

    count &lt;&lt; setw(23) &lt;&lt; <span class="stringliteral">"Procedure"</span> &lt;&lt; <span class="stringliteral">" "</span>
          &lt;&lt; setw(15) &lt;&lt; <span class="stringliteral">"Image"</span> &lt;&lt; <span class="stringliteral">" "</span>
          &lt;&lt; setw(18) &lt;&lt; <span class="stringliteral">"Address"</span> &lt;&lt; <span class="stringliteral">" "</span>
          &lt;&lt; setw(12) &lt;&lt; <span class="stringliteral">"Calls"</span> &lt;&lt; <span class="stringliteral">" "</span>
          &lt;&lt; setw(12) &lt;&lt; <span class="stringliteral">"Instructions"</span> &lt;&lt; endl;

    <span class="keywordflow">for</span> (RTN_COUNT * rc = RtnList; rc; rc = rc-&gt;_next)
    {
        <span class="keywordflow">if</span> (rc-&gt;_icount &gt; 0)
            count &lt;&lt; setw(23) &lt;&lt; rc-&gt;_name &lt;&lt; <span class="stringliteral">" "</span>
                  &lt;&lt; setw(15) &lt;&lt; rc-&gt;_image &lt;&lt; <span class="stringliteral">" "</span>
                  &lt;&lt; setw(18) &lt;&lt; hex &lt;&lt; rc-&gt;_address &lt;&lt; dec &lt;&lt;<span class="stringliteral">" "</span>
                  &lt;&lt; setw(12) &lt;&lt; rc-&gt;_rtnCount &lt;&lt; <span class="stringliteral">" "</span>
                  &lt;&lt; setw(12) &lt;&lt; rc-&gt;_icount &lt;&lt; endl;
    }

}

<span class="comment">// argc, argv are the entire command line, including pin -t &lt;toolname&gt; -- ...</span>
<span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span> * argv[])
{
    <span class="comment">// Initialize symbol table code, needed for rtn instrumentation</span>
    <a class="code" href="group__PIN__CONTROL.html#g8cf4aca0b0bdbc7fc0ae965883d8e3c2">PIN_InitSymbols</a>();

    <span class="comment">// Initialize pin</span>
    <a class="code" href="group__PIN__CONTROL.html#g783d3bd40c3fb2ca51b1f9af31a70c9c">PIN_Init</a>(argc, argv);

    <span class="comment">// Register Routine to be called to instrument rtn</span>
    <a class="code" href="group__RTN__BASIC__API.html#g1208c26573e12bec41d7ffa026dd3089">RTN_AddInstrumentFunction</a>(Routine, 0);

    <span class="comment">// Register Fini to be called when the application exits</span>
    <a class="code" href="group__PIN__CONTROL.html#g879e5a50ab15c9468f2918b260294454">PIN_AddFiniFunction</a>(Fini, 0);
    
    <span class="comment">// Start the program, never returns</span>
    <a class="code" href="group__PIN__CONTROL.html#g70c7d6c2a0d8ddad7595cae915f9a9e7">PIN_StartProgram</a>();
    
    <span class="keywordflow">return</span> 0;
}
</pre></div><h3><a class="anchor" name="StaticInstructionCounts">
Image Instrumentation</a></h3>
It is also possible to use pin to examine binaries without instrumenting them. This is useful when you need to know static properties of an image. The sample tool below counts the number of instructions in an image, but does not insert any instrumentation.<p>
The example can be found in ManualExamples/staticcount.C<p>
<div class="fragment"><pre class="fragment"><span class="comment">/*BEGIN_LEGAL </span>
<span class="comment">INTEL CONFIDENTIAL</span>
<span class="comment">Copyright 2002-2005 Intel Corporation All Rights Reserved.</span>
<span class="comment"></span>
<span class="comment">The source code contained or described herein and all documents</span>
<span class="comment">related to the source code (Material) are owned by Intel Corporation</span>
<span class="comment">or its suppliers or licensors. Title to the Material remains with</span>
<span class="comment">Intel Corporation or its suppliers and licensors. The Material may</span>
<span class="comment">contain trade secrets and proprietary and confidential information of</span>
<span class="comment">Intel Corporation and its suppliers and licensors, and is protected by</span>
<span class="comment">worldwide copyright and trade secret laws and treaty provisions. No</span>
<span class="comment">part of the Material may be used, copied, reproduced, modified,</span>
<span class="comment">published, uploaded, posted, transmitted, distributed, or disclosed in</span>
<span class="comment">any way without Intels prior express written permission.  No license</span>
<span class="comment">under any patent, copyright, trade secret or other intellectual</span>
<span class="comment">property right is granted to or conferred upon you by disclosure or</span>
<span class="comment">delivery of the Materials, either expressly, by implication,</span>
<span class="comment">inducement, estoppel or otherwise. Any license under such intellectual</span>
<span class="comment">property rights must be express and approved by Intel in writing.</span>
<span class="comment"></span>
<span class="comment">Unless otherwise agreed by Intel in writing, you may not remove or</span>
<span class="comment">alter this notice or any other notice embedded in Materials by Intel</span>
<span class="comment">or Intels suppliers or licensors in any way.</span>
<span class="comment">END_LEGAL */</span>
<span class="comment">//</span>
<span class="comment">// This tool prints a trace of image load and unload events</span>
<span class="comment">//</span>

<span class="preprocessor">#include &lt;stdio.h&gt;</span>
<span class="preprocessor">#include "pin.H"</span>


<span class="comment">// Pin calls this function every time a new img is loaded</span>
<span class="comment">// It can instrument the image, but this example merely</span>
<span class="comment">// counts the number of static instructions in the image</span>

VOID ImageLoad(IMG img, VOID *v)
{
    UINT32 count = 0;
    
    <span class="keywordflow">for</span> (SEC sec = <a class="code" href="group__IMG__BASIC__API.html#g827838cfedca451d84c94132180d7577">IMG_SecHead</a>(img); <a class="code" href="group__SEC__BASIC__API.html#g584ce38ee42410cf65bb5c7201760663">SEC_Valid</a>(sec); sec = <a class="code" href="group__SEC__BASIC__API.html#gb33bd7e5debfe27ec77e7f17328cb911">SEC_Next</a>(sec))
    { 
        <span class="keywordflow">for</span> (RTN rtn = <a class="code" href="group__SEC__BASIC__API.html#g6b132c297092644f83681f005b087e24">SEC_RtnHead</a>(sec); <a class="code" href="group__RTN__BASIC__API.html#g6ac855c9a19a3aab44347188e6695875">RTN_Valid</a>(rtn); rtn = <a class="code" href="group__RTN__BASIC__API.html#g491bf55c9718f8751054ebe37b460d65">RTN_Next</a>(rtn))
        {
            <span class="comment">// Prepare for processing of RTN, an  RTN is not broken up into BBLs,</span>
            <span class="comment">// it is merely a sequence of INSs </span>
            <a class="code" href="group__RTN__BASIC__API.html#gf8714086f8aebc9feacccc8cd02dc561">RTN_Open</a>(rtn);
            
            <span class="keywordflow">for</span> (INS ins = <a class="code" href="group__RTN__BASIC__API.html#gb1bd91206939b88057664c46ef8eac86">RTN_InsHead</a>(rtn); <a class="code" href="group__INS__BASIC__API__GEN__IA32.html#g3a8b61fffa9ae4ad9f899b21ce37397c">INS_Valid</a>(ins); ins = <a class="code" href="group__INS__BASIC__API__GEN__IA32.html#g227ce58a739b1573125c11071ecb48de">INS_Next</a>(ins))
            {
                count++;
            }

            <span class="comment">// to preserve space, release data associated with RTN after we have processed it</span>
            <a class="code" href="group__RTN__BASIC__API.html#g37272253377eb65c9eb5ff47ec4f1e6b">RTN_Close</a>(rtn);
        }
    }
    fprintf(stderr, <span class="stringliteral">"Image %s has  %d instructions\n"</span>, <a class="code" href="group__IMG__BASIC__API.html#gbcd40629769c084935422817149fd52f">IMG_Name</a>(img).c_str(), count);
}

<span class="comment">// argc, argv are the entire command line, including pin -t &lt;toolname&gt; -- ...</span>
<span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span> * argv[])
{
    <span class="comment">// prepare for image instrumentation mode</span>
    <a class="code" href="group__PIN__CONTROL.html#g8cf4aca0b0bdbc7fc0ae965883d8e3c2">PIN_InitSymbols</a>();

    <span class="comment">// Initialize pin</span>
    <a class="code" href="group__PIN__CONTROL.html#g783d3bd40c3fb2ca51b1f9af31a70c9c">PIN_Init</a>(argc, argv);

    <span class="comment">// Register ImageLoad to be called when an image is loaded</span>
    <a class="code" href="group__IMG__BASIC__API.html#gde144ad2da442ec59c351475e42565b3">IMG_AddInstrumentFunction</a>(ImageLoad, 0);

    <span class="comment">// Start the program, never returns</span>
    <a class="code" href="group__PIN__CONTROL.html#g70c7d6c2a0d8ddad7595cae915f9a9e7">PIN_StartProgram</a>();
    
    <span class="keywordflow">return</span> 0;
}
</pre></div><h3><a class="anchor" name="DetachPin">
Detaching Pin from the Application</a></h3>
Pin can relinquish control of application any time when invoked via <a class="el" href="group__PIN__CONTROL.html#g6277d16bf33ede39685a26a92fc3cbef">PIN_Detach</a>. Control is returned to the original uninstrumented code and the application runs at native speed. Thereafter no instrumented code is ever executed.<p>
The example can be found in ManualExamples/detach.C<p>
<div class="fragment"><pre class="fragment"><span class="comment">/*BEGIN_LEGAL </span>
<span class="comment">INTEL CONFIDENTIAL</span>
<span class="comment">Copyright 2002-2005 Intel Corporation All Rights Reserved.</span>
<span class="comment"></span>
<span class="comment">The source code contained or described herein and all documents</span>
<span class="comment">related to the source code (Material) are owned by Intel Corporation</span>
<span class="comment">or its suppliers or licensors. Title to the Material remains with</span>
<span class="comment">Intel Corporation or its suppliers and licensors. The Material may</span>
<span class="comment">contain trade secrets and proprietary and confidential information of</span>
<span class="comment">Intel Corporation and its suppliers and licensors, and is protected by</span>
<span class="comment">worldwide copyright and trade secret laws and treaty provisions. No</span>
<span class="comment">part of the Material may be used, copied, reproduced, modified,</span>
<span class="comment">published, uploaded, posted, transmitted, distributed, or disclosed in</span>
<span class="comment">any way without Intels prior express written permission.  No license</span>
<span class="comment">under any patent, copyright, trade secret or other intellectual</span>
<span class="comment">property right is granted to or conferred upon you by disclosure or</span>
<span class="comment">delivery of the Materials, either expressly, by implication,</span>
<span class="comment">inducement, estoppel or otherwise. Any license under such intellectual</span>
<span class="comment">property rights must be express and approved by Intel in writing.</span>
<span class="comment"></span>
<span class="comment">Unless otherwise agreed by Intel in writing, you may not remove or</span>
<span class="comment">alter this notice or any other notice embedded in Materials by Intel</span>
<span class="comment">or Intels suppliers or licensors in any way.</span>
<span class="comment">END_LEGAL */</span>
<span class="preprocessor">#include &lt;stdio.h&gt;</span>
<span class="preprocessor">#include "pin.H"</span>
<span class="preprocessor">#include &lt;iostream&gt;</span>

<span class="comment">// This tool shows how to detach Pin from an </span>
<span class="comment">// application that is under Pin's control.</span>

UINT64 icount = 0;

<span class="preprocessor">#define N 10000</span>
<span class="preprocessor"></span>VOID docount() 
{
    icount++;

    <span class="comment">// Release control of application if 10000 </span>
    <span class="comment">// instructions have been executed</span>
    <span class="keywordflow">if</span> ((icount % N) == 0) 
    {
        <a class="code" href="group__PIN__CONTROL.html#g6277d16bf33ede39685a26a92fc3cbef">PIN_Detach</a>();
    }
}
 
VOID Instruction(INS ins, VOID *v)
{
    <a class="code" href="group__INS__INST__API.html#g74a956a0acde197043d04f4adcde4626">INS_InsertCall</a>(ins, <a class="code" href="group__INST__ARGS.html#gg707ea08e31f44f4a81e2a7766123bad77c7cbebb7a62a40e9f803b1db2e6ce20">IPOINT_BEFORE</a>, (AFUNPTR)docount, <a class="code" href="group__INST__ARGS.html#gg089c27ca15e9ff139dd3a3f8a6f8451dea5ff6624d8e6a49ba1da2f696fdac85">IARG_END</a>);
}

VOID ByeWorld(VOID *v)
{
    std::cerr &lt;&lt; endl &lt;&lt; <span class="stringliteral">"Detached at icount = "</span> &lt;&lt; N &lt;&lt; endl;
}

<span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span> * argv[])
{
    <a class="code" href="group__PIN__CONTROL.html#g783d3bd40c3fb2ca51b1f9af31a70c9c">PIN_Init</a>(argc, argv);

    <span class="comment">// Callback function to invoke for every </span>
    <span class="comment">// execution of an instruction</span>
    <a class="code" href="group__INS__INST__API.html#g56957614e1271afdd912c485c87fd406">INS_AddInstrumentFunction</a>(Instruction, 0);
    
    <span class="comment">// Callback functions to invoke before</span>
    <span class="comment">// Pin releases control of the application</span>
    <a class="code" href="group__PIN__CONTROL.html#g0b8427c78ba3888e1c58fba45079ddce">PIN_AddDetachFunction</a>(ByeWorld, 0);
    
    <span class="comment">// Never returns</span>
    <a class="code" href="group__PIN__CONTROL.html#g70c7d6c2a0d8ddad7595cae915f9a9e7">PIN_StartProgram</a>();
    
    <span class="keywordflow">return</span> 0;
}
</pre></div><p>
======================================================================================== <h2><a class="anchor" name="CALLBACK">
Call Backs</a></h2>
========================================================================================<p>
The examples in the previous section have introduced a number of ways to register call back functions via the Pin API:<p>
<ul>
<li><a class="el" href="group__INS__INST__API.html#g56957614e1271afdd912c485c87fd406">INS_AddInstrumentFunction</a> (INSCALLBACK fun, VOID *val)</li><li><a class="el" href="group__TRACE__BASIC__API.html#g3418f705242d4f3b60b98437226e522b">TRACE_AddInstrumentFunction</a> (TRACECALLBACK fun, VOID *val)</li><li><a class="el" href="group__RTN__BASIC__API.html#g1208c26573e12bec41d7ffa026dd3089">RTN_AddInstrumentFunction</a> (RTNCALLBACK fun, VOID *val)</li><li><a class="el" href="group__IMG__BASIC__API.html#gde144ad2da442ec59c351475e42565b3">IMG_AddInstrumentFunction</a> (IMGCALLBACK fun, VOID *val)</li><li><a class="el" href="group__PIN__CONTROL.html#g879e5a50ab15c9468f2918b260294454">PIN_AddFiniFunction</a> (FINICALLBACK fun, VOID *val)</li><li><a class="el" href="group__PIN__CONTROL.html#g0b8427c78ba3888e1c58fba45079ddce">PIN_AddDetachFunction</a> (DETACHCALLBACK fun, VOID *val)</li></ul>
<p>
The extra parameter <code>val</code> (shared by all the registration functions) will be passed to <code>fun</code> as its second argument whenever it is "called back". This is a standard mechanism used in GUI programming with call backs.<p>
If this feature is not needed, it is safe to pass 0 for <code>val</code> when registering a call back. The expected use of <code>val</code> is to pass a pointer to an instance of a class. Since <code>val</code> is a generic pointer, <code>fun</code> must cast it back to an object before dereferencing the pointer.<p>
======================================================================================== <h2><a class="anchor" name="EX">
Applying a Pintool to an Application</a></h2>
========================================================================================<p>
An application and a tool are invoked as follows:<p>
<div class="fragment"><pre class="fragment">pin [pin-option]... -t [toolname] [tool-options]... -- [application] [application-option]..
</pre></div><p>
The following Pin-options are currently available: <ul>
<li>
-t <em>toolname</em>: specifies the Pintool to use. </li>
<li>
-pause_tool n: is a useful Pin-option which prints out the process id and pauses Pin for n seconds to permit attaching with gdb. See <a class="el" href="index.html#DEBUGGING">Tips for Debugging a Pintool</a> </li>
<li>
-pid <em>pid</em>: attach Pin and the Pintool to an already running executable with the given process id </li>
</ul>
<p>
The tool-options follow immediately after the tool specification and depend on the tool used.<p>
Everything following the <code>--</code> is the command line for the application.<p>
For example, to apply the itrace example (<a class="el" href="index.html#IAddressTrace">Instruction Address Trace (Instruction Instrumentation)</a>) to a run of the "ls" program:<p>
<div class="fragment"><pre class="fragment">pin -t itrace -- /bin/ls
</pre></div><p>
To get a listing of the available command line options for Pin:<p>
<div class="fragment"><pre class="fragment">pin -h
</pre></div><p>
To get a listing of the available command line options for the itrace example:<p>
<div class="fragment"><pre class="fragment">pin -t itrace -h -- /bin/ls
</pre></div><p>
Note that in the last case <code>/bin/ls</code> is necessary on the command line but will not be executed.<p>
IMPORTANT: The description above assumes that the application is a program binary (and not a shell script). If your application is invoked indirectly (from a shell script or using 'exec') then you need to change the actual invocation of the program binary by prefixing it with pin/pintool options. Here's one way of doing that:<p>
<div class="fragment"><pre class="fragment"><span class="preprocessor"> # Track down the actual application binary, say it is 'application_binary'.</span>
<span class="preprocessor"></span> % mv application_binary application_binary.real

<span class="preprocessor"> # Write a shell script named 'application_binary' with the following contents.</span>
<span class="preprocessor"></span><span class="preprocessor"> # (change 'itrace' to your desired tool)</span>
<span class="preprocessor"></span>
<span class="preprocessor"> #!/bin/sh</span>
<span class="preprocessor"> pin -t itrace -- application_binary.real $*</span>
</pre></div><p>
After you do this, whenever 'application_binary' is invoked indirectly (from some shell script or using 'exec'), the real binary will get invoked with the right pin/pintool options. ======================================================================================== <h2><a class="anchor" name="DEBUGGING">
Tips for Debugging a Pintool</a></h2>
========================================================================================<p>
There are 3 different programs residing in the address space. The application, the Pin instrumentation engine, and your Pintool. This section describes how to use gdb to find bugs in a Pintool. You cannot run Pin directly from gdb since Pin uses the debugging API to start the application. Instead, you must invoke Pin from the command line with the -pause_tool switch, and use gdb to attach to the Pin process from another window. The -pause_tool n switch makes Pin print out the process identifier (pid) and pause for n seconds.<p>
If your tool is called opcodemix and the application is /bin/ls, you can use gdb as follows. Start gdb with your tool, but do not use the run command:<p>
<div class="fragment"><pre class="fragment">$ gdb opcodemix
GNU gdb 5.2.1
Copyright 2002 Free Software Foundation, Inc.
GDB is free software, covered by the GNU General Public License, and you are
welcome to change it and/or distribute copies of it under certain conditions.
Type <span class="stringliteral">"show copying"</span> to see the conditions.
There is absolutely no warranty <span class="keywordflow">for</span> GDB.  Type <span class="stringliteral">"show warranty"</span> <span class="keywordflow">for</span> details.
This GDB was configured as <span class="stringliteral">"i686-pc-linux-gnu"</span>...
(gdb)
</pre></div><p>
In another window, start your application with the -pause_tool switch:<p>
<div class="fragment"><pre class="fragment">$ pin -pause_tool 5 -t opcodemix -- /bin/ls
Pausing to attach to pid 28769
</pre></div><p>
Then go back to gdb and attach to the process:<p>
<div class="fragment"><pre class="fragment">(gdb) attach 28769
Attaching to program: .../build-ia32/SimpleExamples/opcodemix, process 28769
0x011ef361 in ?? ()
(gdb)
</pre></div><p>
Now, instead of using the gdb run command, you use the <code>cont</code> command to continue execution. You can also set breakpoints as normal:<p>
<div class="fragment"><pre class="fragment">(gdb) <span class="keywordflow">break</span> main
Breakpoint 1 at 0x5048d30: file .../PinTools/SimpleExamples/opcodemix.C, line 232.
(gdb) cont
Continuing.

Breakpoint 1, main (argc=6, argv=0x4fef534)
    at .../PinTools/SimpleExamples/opcode.C:232
(gdb) 
</pre></div><p>
If the program does not exit, then you should detach so gdb will release control:<p>
<div class="fragment"><pre class="fragment">(gdb) detach
Detaching from program: .../build-ia32/SimpleExamples/opcodemix, process 28769
(gdb) 
</pre></div><p>
If you recompile your program and then use the run command, gdb will notice that the binary has been changed and reread the debug information from the file. This does not happen automatically when using attach. You must use the file command to make gdb reread the debug information:<p>
<div class="fragment"><pre class="fragment">(gdb) file opcodemix
Load <span class="keyword">new</span> symbol table from <span class="stringliteral">"opcodemix"</span>? (y or n) y
Reading symbols from opcodemix...
done.
(gdb) 
</pre></div><p>
======================================================================================== <h2><a class="anchor" name="PERFORMANCE">
Performance Consideration When Writing  a Pintool</a></h2>
========================================================================================<p>
They way a Pintool is written can have great impact on the performace of the tool, i.e. how much it slows down the applications it is instrumenting. This section demonstrates some techniques that can be used to improve tool performance. Let's start with an example. The following piece of code is derived from the Examples/edgcnt.C:<p>
The instrumentation component of the tool is show below<p>
<div class="fragment"><pre class="fragment">VOID Instruction(INS ins, <span class="keywordtype">void</span> *v)
{
      ...

      <span class="keywordflow">if</span> ( [ins is a branch or a call instruction] ) 
      {
          
        
        <a class="code" href="group__INS__INST__API.html#g74a956a0acde197043d04f4adcde4626">INS_InsertCall</a>(ins, <a class="code" href="group__INST__ARGS.html#gg707ea08e31f44f4a81e2a7766123bad77c7cbebb7a62a40e9f803b1db2e6ce20">IPOINT_BEFORE</a>, (AFUNPTR) docount2,
                       <a class="code" href="group__INST__ARGS.html#gg089c27ca15e9ff139dd3a3f8a6f8451d623ad95758bce14fcb9427beef53736a">IARG_INST_PTR</a>,
                       <a class="code" href="group__INST__ARGS.html#gg089c27ca15e9ff139dd3a3f8a6f8451da1b650f4229df434f3ac5ef61f14d0ed">IARG_BRANCH_TARGET_ADDR</a>,
                       <a class="code" href="group__INST__ARGS.html#gg089c27ca15e9ff139dd3a3f8a6f8451d28140354d575f6b6404a6833552fed47">IARG_BRANCH_TAKEN</a>,
                       <a class="code" href="group__INST__ARGS.html#gg089c27ca15e9ff139dd3a3f8a6f8451dea5ff6624d8e6a49ba1da2f696fdac85">IARG_END</a>);
      }

      ...
}
</pre></div><p>
The analysis component looks like this: <div class="fragment"><pre class="fragment">VOID docount2( ADDRINT src, ADDRINT dst, INT32 taken )
{
    <span class="keywordflow">if</span>(!taken) <span class="keywordflow">return</span>;
    COUNTER *pedg = Lookup( src,dst );
    pedg-&gt;_count++;
} 
</pre></div><p>
The purpose of the tool is to count how often each controlflow changing edge in the control flowgraph is traversed. The tool considers both calls and branches but for brevity we will not mention branches in our description. The tool works as follows: The instrumentation component instruments each branch with a call to docount2. As parameters we pass in the origin and the target of the branch and whether the branch was taken or not. Branch origin and target represent of the source and destination of the controlflow edges. If a branch is not taken the controlflow does not change and hence the analysis routine returns right away. If the branch is taken we use the src and dst parameters to look up the counter associated with this edge (Lookup will create a new one if this edge has not been seen before) and increment the counter. Note, that the tool could have been simplified somewhat by using IPOINT_TAKEN_BRANCH option with <a class="el" href="group__INS__INST__API.html#g74a956a0acde197043d04f4adcde4626">INS_InsertCall()</a>.<h3><a class="anchor" name="shifting_computation">
Shifting Compuation for Analysis to Instrumentation Code</a></h3>
About every 5th instruction executed in a typical application is a branch. Lookup will called whenever these instruction are executed, causing significant application slowdown. To improve the situation we note that the instrumentation code is typically called only once for every instruction, while the analysis code is called everytime the instruction is executed. If we can somehow shift computation from the analysis code to the instrumentation code we will improve the overall performance. Our example tools offer multiple such opportunites which will explore in turn. The first observation is that for most branches we can find out inside of Instruction() what the branch target will be . For those branches we can call Lookup inside of Instruction() rather than in docount2(), for indirect branches which are relatively rare we still have to use our original approach. All this is reflected in the folling code. We add a second "lighter" analsysis function, docount. While the original docount2() remains unchanged:<p>
<div class="fragment"><pre class="fragment">VOID docount( COUNTER *pedg, INT32 taken )
{
    <span class="keywordflow">if</span>( !taken ) <span class="keywordflow">return</span>;
    pedg-&gt;_count++;
}
</pre></div><p>
And the instrumentation will be somewhat more complex:<p>
<div class="fragment"><pre class="fragment">VOID Instruction(INS ins, <span class="keywordtype">void</span> *v)
{
      ...

    <span class="keywordflow">if</span> (<a class="code" href="group__INS__BASIC__API__GEN__IA32.html#g65b3471617b2f4d87980b95e69421ea0">INS_IsDirectBranchOrCall</a>(ins))
    {
        COUNTER *pedg = Lookup( <a class="code" href="group__INS__BASIC__API__GEN__IA32.html#g6b685dec56c6a045f8cc3c03f52d054a">INS_Address</a>(ins),  <a class="code" href="group__INS__BASIC__API__GEN__IA32.html#g4f6e9ddc2fbc4721b9447009a29b487f">INS_DirectBranchOrCallTargetAddress</a>(ins) );

        <a class="code" href="group__INS__INST__API.html#g74a956a0acde197043d04f4adcde4626">INS_InsertCall</a>(ins, <a class="code" href="group__INST__ARGS.html#gg707ea08e31f44f4a81e2a7766123bad77c7cbebb7a62a40e9f803b1db2e6ce20">IPOINT_BEFORE</a>, (AFUNPTR) docount, 
                       <a class="code" href="group__INST__ARGS.html#gg089c27ca15e9ff139dd3a3f8a6f8451d34126f334d65afac69784351a03615ad">IARG_ADDRINT</a>, pedg, 
                       <a class="code" href="group__INST__ARGS.html#gg089c27ca15e9ff139dd3a3f8a6f8451d28140354d575f6b6404a6833552fed47">IARG_BRANCH_TAKEN</a>, 
                       <a class="code" href="group__INST__ARGS.html#gg089c27ca15e9ff139dd3a3f8a6f8451dea5ff6624d8e6a49ba1da2f696fdac85">IARG_END</a>);           
    }
    <span class="keywordflow">else</span>
    {
        <a class="code" href="group__INS__INST__API.html#g74a956a0acde197043d04f4adcde4626">INS_InsertCall</a>(ins, <a class="code" href="group__INST__ARGS.html#gg707ea08e31f44f4a81e2a7766123bad77c7cbebb7a62a40e9f803b1db2e6ce20">IPOINT_BEFORE</a>, (AFUNPTR) docount2,
                       <a class="code" href="group__INST__ARGS.html#gg089c27ca15e9ff139dd3a3f8a6f8451d623ad95758bce14fcb9427beef53736a">IARG_INST_PTR</a>,
                       <a class="code" href="group__INST__ARGS.html#gg089c27ca15e9ff139dd3a3f8a6f8451da1b650f4229df434f3ac5ef61f14d0ed">IARG_BRANCH_TARGET_ADDR</a>,
                       <a class="code" href="group__INST__ARGS.html#gg089c27ca15e9ff139dd3a3f8a6f8451d28140354d575f6b6404a6833552fed47">IARG_BRANCH_TAKEN</a>,
                       <a class="code" href="group__INST__ARGS.html#gg089c27ca15e9ff139dd3a3f8a6f8451dea5ff6624d8e6a49ba1da2f696fdac85">IARG_END</a>);
    }

      ...
}
</pre></div><h3><a class="anchor" name="shifting_computation">
Shifting Compuation for Analysis to Instrumentation Code</a></h3>
The code for docount() is very compact which besides the obvious performance advantages may also cause it to be inlined by pin thereby avoiding the overhead of a call. The heuristics for when a analysis routine is inlined by pin are subject to change. But small routines without any controlflow (single basic block) are almost guaranteed to be inlined. Unfortunately, docount() does have (albeit limited) controlflow. Observing that the parameter, taken, will be zero or one we can eliminate the remaining controlflow as follows:<p>
<div class="fragment"><pre class="fragment">VOID docount( COUNTER *pedg, INT32 taken )
{
    pedg-&gt;_count += taken;
}
</pre></div><p>
There is now no question whether docount() will be inlined or not.<h3><a class="anchor" name="let_pin_decide">
Letting Pin Decide Where to Instrument</a></h3>
At times we do not care about the exact point where calls to analysis code are being inserted as long as it is within a given basic block. In this case we can let Pin make the decission where to insert. This has the advantage that Pin can select am insertion point that requires minimal register saving and restoring. The following code from ManualExamples/inscount2.C shows how this is done for the instruction count example using IPOINT_ANYWHERE with <a class="el" href="group__BBL__BASIC__API.html#geee9d7a6253d49d226bbed3f35768169">BBL_InsertCall()</a>.<p>
<div class="fragment"><pre class="fragment"><span class="comment">/*BEGIN_LEGAL </span>
<span class="comment">INTEL CONFIDENTIAL</span>
<span class="comment">Copyright 2002-2005 Intel Corporation All Rights Reserved.</span>
<span class="comment"></span>
<span class="comment">The source code contained or described herein and all documents</span>
<span class="comment">related to the source code (Material) are owned by Intel Corporation</span>
<span class="comment">or its suppliers or licensors. Title to the Material remains with</span>
<span class="comment">Intel Corporation or its suppliers and licensors. The Material may</span>
<span class="comment">contain trade secrets and proprietary and confidential information of</span>
<span class="comment">Intel Corporation and its suppliers and licensors, and is protected by</span>
<span class="comment">worldwide copyright and trade secret laws and treaty provisions. No</span>
<span class="comment">part of the Material may be used, copied, reproduced, modified,</span>
<span class="comment">published, uploaded, posted, transmitted, distributed, or disclosed in</span>
<span class="comment">any way without Intels prior express written permission.  No license</span>
<span class="comment">under any patent, copyright, trade secret or other intellectual</span>
<span class="comment">property right is granted to or conferred upon you by disclosure or</span>
<span class="comment">delivery of the Materials, either expressly, by implication,</span>
<span class="comment">inducement, estoppel or otherwise. Any license under such intellectual</span>
<span class="comment">property rights must be express and approved by Intel in writing.</span>
<span class="comment"></span>
<span class="comment">Unless otherwise agreed by Intel in writing, you may not remove or</span>
<span class="comment">alter this notice or any other notice embedded in Materials by Intel</span>
<span class="comment">or Intels suppliers or licensors in any way.</span>
<span class="comment">END_LEGAL */</span>
<span class="preprocessor">#include &lt;iostream&gt;</span>
<span class="preprocessor">#include &lt;fstream&gt;</span>
<span class="preprocessor">#include "pin.H"</span>

<span class="comment">// The running count of instructions is kept here</span>
UINT64 icount = 0;

<span class="comment">// This function is called before every block</span>
VOID docount(INT32 c) { icount += c; }
    
<span class="comment">// Pin calls this function every time a new basic block is encountered</span>
<span class="comment">// It inserts a call to docount</span>
VOID Trace(<a class="code" href="group__TRACE__BASIC__API.html#g2546ffa074ba96447052652c556f0821">TRACE</a> trace, VOID *v)
{
    <span class="comment">// Visit every basic block  in the trace</span>
    <span class="keywordflow">for</span> (BBL bbl = <a class="code" href="group__TRACE__BASIC__API.html#g008abc5ba1af8d9e9cd073ffe0aefa18">TRACE_BblHead</a>(trace); <a class="code" href="group__BBL__BASIC__API.html#g58a8d019cd09ce46cfe431ec8f14a075">BBL_Valid</a>(bbl); bbl = <a class="code" href="group__BBL__BASIC__API.html#gdd7141abb47139b52922e04e0c4a10f3">BBL_Next</a>(bbl))
    {
        <span class="comment">// Insert a call to docount for every bbl, passing the number of instructions.</span>
        <span class="comment">// IPOINT_ANYWHERE allows Pin to schedule the call anywhere in the bbl to obtain best performance.</span>
        
        <a class="code" href="group__BBL__BASIC__API.html#geee9d7a6253d49d226bbed3f35768169">BBL_InsertCall</a>(bbl, <a class="code" href="group__INST__ARGS.html#gg707ea08e31f44f4a81e2a7766123bad7cf7dee2063098dd79907d19f9c7df65d">IPOINT_ANYWHERE</a>, (AFUNPTR)docount, <a class="code" href="group__INST__ARGS.html#gg089c27ca15e9ff139dd3a3f8a6f8451dbd19b79248899659441e56e4738d5bfd">IARG_UINT32</a>, <a class="code" href="group__BBL__BASIC__API.html#g76ceb2d9e0fb974d3c3769b2413ed634">BBL_NumIns</a>(bbl), <a class="code" href="group__INST__ARGS.html#gg089c27ca15e9ff139dd3a3f8a6f8451dea5ff6624d8e6a49ba1da2f696fdac85">IARG_END</a>);
    }
}

KNOB&lt;string&gt; KnobOutputFile(<a class="code" href="group__KNOB__BASIC.html#ggd45510089e3b85a88df038e900e9f8ba576ddd3b58b1121ff4070df605951cf6">KNOB_MODE_WRITEONCE</a>, <span class="stringliteral">"pintool"</span>,
    <span class="stringliteral">"o"</span>, <span class="stringliteral">""</span>, <span class="stringliteral">"specify optional output file name"</span>);

<span class="comment">// This function is called when the application exits</span>
VOID Fini(INT32 code, VOID *v)
{
    ofstream OutFile;
    std::cerr &lt;&lt; <span class="stringliteral">"Count "</span> &lt;&lt; icount &lt;&lt; endl;
    <span class="keywordflow">if</span>(KnobOutputFile.Value() != <span class="stringliteral">""</span>)
    {
        OutFile.open(KnobOutputFile.Value().c_str());
        OutFile.setf(ios::showbase);
        OutFile &lt;&lt; <span class="stringliteral">"Count "</span> &lt;&lt; icount &lt;&lt; endl;
        OutFile.close();
    }
}

<span class="comment">// argc, argv are the entire command line, including pin -t &lt;toolname&gt; -- ...</span>
<span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span> * argv[])
{
    <span class="comment">// Initialize pin</span>
    <a class="code" href="group__PIN__CONTROL.html#g783d3bd40c3fb2ca51b1f9af31a70c9c">PIN_Init</a>(argc, argv);

    <span class="comment">// Register Instruction to be called to instrument instructions</span>
    <a class="code" href="group__TRACE__BASIC__API.html#g3418f705242d4f3b60b98437226e522b">TRACE_AddInstrumentFunction</a>(Trace, 0);

    <span class="comment">// Register Fini to be called when the application exits</span>
    <a class="code" href="group__PIN__CONTROL.html#g879e5a50ab15c9468f2918b260294454">PIN_AddFiniFunction</a>(Fini, 0);
    
    <span class="comment">// Start the program, never returns</span>
    <a class="code" href="group__PIN__CONTROL.html#g70c7d6c2a0d8ddad7595cae915f9a9e7">PIN_StartProgram</a>();
    
    <span class="keywordflow">return</span> 0;
}
</pre></div><h3><a class="anchor" name="partial_inline">
Rewriting Conditional Analysis Code to Help Pin Inline</a></h3>
Pin improves instrumentation performance by automatically inlining analysis routines that have no control-flow changes. Of course, many analysis routines do have control-flow changes. One particularly common case is that an analysis routine has a single "if-then" test, where a small amount of analysis code plus the test is always executed but the "then" part is executed only once a while. To inline this common case, Pin provides a set of conditional instrumentation APIs for the tool writer to rewrite their analysis routines into a form that does not have control-flow changes. The following example from ManualExamples/isampling.C illustrates how such rewriting can be done:<p>
<div class="fragment"><pre class="fragment"><span class="comment">/*BEGIN_LEGAL </span>
<span class="comment">INTEL CONFIDENTIAL</span>
<span class="comment">Copyright 2002-2005 Intel Corporation All Rights Reserved.</span>
<span class="comment"></span>
<span class="comment">The source code contained or described herein and all documents</span>
<span class="comment">related to the source code (Material) are owned by Intel Corporation</span>
<span class="comment">or its suppliers or licensors. Title to the Material remains with</span>
<span class="comment">Intel Corporation or its suppliers and licensors. The Material may</span>
<span class="comment">contain trade secrets and proprietary and confidential information of</span>
<span class="comment">Intel Corporation and its suppliers and licensors, and is protected by</span>
<span class="comment">worldwide copyright and trade secret laws and treaty provisions. No</span>
<span class="comment">part of the Material may be used, copied, reproduced, modified,</span>
<span class="comment">published, uploaded, posted, transmitted, distributed, or disclosed in</span>
<span class="comment">any way without Intels prior express written permission.  No license</span>
<span class="comment">under any patent, copyright, trade secret or other intellectual</span>
<span class="comment">property right is granted to or conferred upon you by disclosure or</span>
<span class="comment">delivery of the Materials, either expressly, by implication,</span>
<span class="comment">inducement, estoppel or otherwise. Any license under such intellectual</span>
<span class="comment">property rights must be express and approved by Intel in writing.</span>
<span class="comment"></span>
<span class="comment">Unless otherwise agreed by Intel in writing, you may not remove or</span>
<span class="comment">alter this notice or any other notice embedded in Materials by Intel</span>
<span class="comment">or Intels suppliers or licensors in any way.</span>
<span class="comment">END_LEGAL */</span>
<span class="comment">/*</span>
<span class="comment"> *  This file contains a Pintool for sampling the IPs of instruction executed.</span>
<span class="comment"> *  It serves as an example of a more efficient way to write analysis routines</span>
<span class="comment"> *  that include conditional tests.</span>
<span class="comment"> *  Currently, it works on IA32 and EM64T.</span>
<span class="comment"> */</span>

<span class="preprocessor">#include &lt;stdio.h&gt;</span>
<span class="preprocessor">#include "pin.H"</span>

FILE * trace;

<span class="keyword">const</span> INT32 N = 100000;
<span class="keyword">const</span> INT32 M =  50000;

INT32 icount = N;

<span class="comment">/*</span>
<span class="comment"> *  IP-sampling could be done in a single analysis routine like:</span>
<span class="comment"> *</span>
<span class="comment"> *        VOID IpSample(VOID *ip)</span>
<span class="comment"> *        {</span>
<span class="comment"> *            --icount;</span>
<span class="comment"> *            if (icount == 0)</span>
<span class="comment"> *            {</span>
<span class="comment"> *               fprintf(trace, "%p\n", ip);</span>
<span class="comment"> *               icount = N + rand() % M;</span>
<span class="comment"> *            }</span>
<span class="comment"> *        }</span>
<span class="comment"> *</span>
<span class="comment"> *  However, we break IpSample() into two analysis routines,</span>
<span class="comment"> *  CountDown() and PrintIp(), to facilitate Pin inlining CountDown()</span>
<span class="comment"> *  (which is the much more frequently executed one than PrintIp()).</span>
<span class="comment"> */</span>

INT32 CountDown()
{
    --icount;
    <span class="keywordflow">return</span> (icount==0);
}


<span class="comment">// The IP of the current instruction will be printed and</span>
<span class="comment">// the icount will be reset to a random number between N and N+M.</span>
VOID PrintIp(VOID *ip)
{
    fprintf(trace, <span class="stringliteral">"%p\n"</span>, ip);
    
    <span class="comment">// Prepare for next period</span>
    icount = N + rand() % M; <span class="comment">// random number from N to N+M</span>
}


<span class="comment">// Pin calls this function every time a new instruction is encountered</span>
VOID Instruction(INS ins, VOID *v)
{
    <span class="comment">// CountDown() is called for every instruction executed</span>
    <a class="code" href="group__INS__INST__API.html#g7907ad8ebd991b9e24df3b3b9cec4cac">INS_InsertIfCall</a>(ins, <a class="code" href="group__INST__ARGS.html#gg707ea08e31f44f4a81e2a7766123bad77c7cbebb7a62a40e9f803b1db2e6ce20">IPOINT_BEFORE</a>, (AFUNPTR)CountDown, <a class="code" href="group__INST__ARGS.html#gg089c27ca15e9ff139dd3a3f8a6f8451dea5ff6624d8e6a49ba1da2f696fdac85">IARG_END</a>);
    
    <span class="comment">// PrintIp() is called only when the last CountDown() returns a non-zero value.</span>
    <a class="code" href="group__INS__INST__API.html#g952b2b061d3fa8f1cc4d5d59fef53a69">INS_InsertThenCall</a>(ins, <a class="code" href="group__INST__ARGS.html#gg707ea08e31f44f4a81e2a7766123bad77c7cbebb7a62a40e9f803b1db2e6ce20">IPOINT_BEFORE</a>, (AFUNPTR)PrintIp, <a class="code" href="group__INST__ARGS.html#gg089c27ca15e9ff139dd3a3f8a6f8451d623ad95758bce14fcb9427beef53736a">IARG_INST_PTR</a>, <a class="code" href="group__INST__ARGS.html#gg089c27ca15e9ff139dd3a3f8a6f8451dea5ff6624d8e6a49ba1da2f696fdac85">IARG_END</a>);
    
}

<span class="comment">// This function is called when the application exits</span>
VOID Fini(INT32 code, VOID *v)
{
    fprintf(trace, <span class="stringliteral">"#eof\n"</span>);
    fclose(trace);
}

<span class="comment">// argc, argv are the entire command line, including pin -t &lt;toolname&gt; -- ...</span>
<span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span> * argv[])
{
    trace = fopen(<span class="stringliteral">"isampling.out"</span>, <span class="stringliteral">"w"</span>);
    
    <span class="comment">// Initialize pin</span>
    <a class="code" href="group__PIN__CONTROL.html#g783d3bd40c3fb2ca51b1f9af31a70c9c">PIN_Init</a>(argc, argv);

    <span class="comment">// Register Instruction to be called to instrument instructions</span>
    <a class="code" href="group__INS__INST__API.html#g56957614e1271afdd912c485c87fd406">INS_AddInstrumentFunction</a>(Instruction, 0);

    <span class="comment">// Register Fini to be called when the application exits</span>
    <a class="code" href="group__PIN__CONTROL.html#g879e5a50ab15c9468f2918b260294454">PIN_AddFiniFunction</a>(Fini, 0);
    
    <span class="comment">// Start the program, never returns</span>
    <a class="code" href="group__PIN__CONTROL.html#g70c7d6c2a0d8ddad7595cae915f9a9e7">PIN_StartProgram</a>();
    
    <span class="keywordflow">return</span> 0;
}
</pre></div><p>
In the above example, the original analysis routine IpSample() has a conditional control-flow change. It is rewritten into two analysis routines: CountDown() and PrintIp(). CountDown() is the simpler one of the two, which doesn't have control-flow change. It also performs the original conditional test and returns the test result. We use the conditional instrumentaton APIs <a class="el" href="group__INS__INST__API.html#g7907ad8ebd991b9e24df3b3b9cec4cac">INS_InsertIfCall()</a> and <a class="el" href="group__INS__INST__API.html#g952b2b061d3fa8f1cc4d5d59fef53a69">INS_InsertThenCall()</a> to tell Pin that tbe analysis routine specified by an <a class="el" href="group__INS__INST__API.html#g952b2b061d3fa8f1cc4d5d59fef53a69">INS_InsertThenCall()</a> (i.e. PrintIp() in this example) is executed only if the result of the analysis routine specified by the previous <a class="el" href="group__INS__INST__API.html#g7907ad8ebd991b9e24df3b3b9cec4cac">INS_InsertIfCall()</a> (i.e. CountDown() in this example) is non-zero. Now CountDown(), the common case, can be inlined by Pin, and only once a while does Pin need to execute PrintIp(), the non-inlined case.<p>
======================================================================================== <h2><a class="anchor" name="INSTALLATION">
Installing Pin</a></h2>
========================================================================================<p>
To install a kit, unpack a kit and change to the directory:<p>
<div class="fragment"><pre class="fragment">$ tar zxf /proj/vssad/proj/pin/Kits/pin-2.0-776-ia32.tar.gz
$ cd pin-2.0-776-ia32/
</pre></div><p>
Build and test the examples from the manual<p>
<div class="fragment"><pre class="fragment">$ cd ManualExamples/
$ make test
g++ -c -Wall -Werror -Wno-unknown-pragmas -I../Include -DTARGET_IA32 -g1 -o pinatrace.o pinatrace.C
g++ -<span class="keyword">static</span> -Wl,-wrap,mmap,-wrap,__mmap,-wrap,brk,-wrap,__brk,--section-start,.interp=0x05048000 
 -g1 -o pinatrace pinatrace.o -L../Lib/ -lpin -ldwarf -lelf -lencp68 -ldecp68
../Bin/pin -t pinatrace -- /bin/cp makefile makefile.copy; cmp makefile makefile.copy
g++ -c -Wall -Werror -Wno-unknown-pragmas -I../Include -DTARGET_IA32 -g1 -o inscount0.o inscount0.C
g++ -<span class="keyword">static</span> -Wl,-wrap,mmap,-wrap,__mmap,-wrap,brk,-wrap,__brk,--section-start,.interp=0x05048000 
 -g1 -o inscount0 inscount0.o -L../Lib/ -lpin -ldwarf -lelf -lencp68 -ldecp68
../Bin/pin -t inscount0 -- /bin/cp makefile makefile.copy; cmp makefile makefile.copy
Count 277395
g++ -c -Wall -Werror -Wno-unknown-pragmas -I../Include -DTARGET_IA32 -g1 -o itrace.o itrace.C
g++ -<span class="keyword">static</span> -Wl,-wrap,mmap,-wrap,__mmap,-wrap,brk,-wrap,__brk,--section-start,.interp=0x05048000 
 -g1 -o itrace itrace.o -L../Lib/ -lpin -ldwarf -lelf -lencp68 -ldecp68
../Bin/pin -t itrace -- /bin/cp makefile makefile.copy; cmp makefile makefile.copy
g++ -c -Wall -Werror -Wno-unknown-pragmas -I../Include -DTARGET_IA32 -g1 -o proccount.o proccount.C
g++ -<span class="keyword">static</span> -Wl,-wrap,mmap,-wrap,__mmap,-wrap,brk,-wrap,__brk,--section-start,.interp=0x05048000 
 -g1 -o proccount proccount.o -L../Lib/ -lpin -ldwarf -lelf -lencp68 -ldecp68
../Bin/pin -t proccount -- /bin/cp makefile makefile.copy; cmp makefile makefile.copy
$
</pre></div><p>
Run one of the sample tools from the installed directory<p>
<div class="fragment"><pre class="fragment">$ ../Bin/pin -t pinatrace -- /bin/ls
_insprofiler.C  atrace.out   inscount0.o    itrace.C    proccount
atrace          imageload.C  inscount1.C    itrace.o    proccount.C
atrace.C        inscount0    insprofiler.C  itrace.out  proccount.o
atrace.o        inscount0.C  itrace         makefile    proccount.out
$ head pinatrace.out 
0x40001ee0: R 0xbfffe1e8
0x40001efd: W 0xbfffe224
0x40001f09: W 0xbfffe228
0x40001f20: W 0xbfffe2b4
0x40001f20: W 0xbfffe2b8
0x40001f20: W 0xbfffe2bc
0x40001f20: W 0xbfffe2c0
0x40001f20: W 0xbfffe2c4
0x40001f20: W 0xbfffe2c8
0x40001f20: W 0xbfffe2cc
$ 
</pre></div><p>
To write your own tool, copy one of the example directories and edit the makefile to add your tool.<p>
======================================================================================== <h2><a class="anchor" name="RESTRICTIONS">
Unsupported features and restrictions</a></h2>
========================================================================================<p>
Each kit contains Pin and libraries for a specific architecture. Make sure the kit you download is for the right architecture. The Pin libraries use C++, and the compiler you use to build the tool must be compatible with the Pin library. This restriction only applies to building tools; you can instrument applications built by any compiler.<p>
See the README file in the kit for specific information about compiler version and other limitations. If your compiler is not compatible with the kit, send mail to <a href="mailto:Pin.Project@intel.com">Pin.Project@intel.com</a>.<p>
======================================================================================== <h2><a class="anchor" name="FEEDBACK">
Questions? Bugs?</a></h2>
========================================================================================<p>
Send bugs and questions to <a href="mailto:Pin.Project@intel.com">Pin.Project@intel.com</a>. Complete bug reports that are easy to reproduce are fixed faster, so try to provide as much information as possible. Include: kit number, your OS version, compiler version. Try to reproduce the problem in a simple example that you can send us. <hr size="1"><address style="align: right;"><small>Generated on Fri Feb 23 14:20:22 2007 for Pin by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.4.6 </small></address>
</body>
</html>
